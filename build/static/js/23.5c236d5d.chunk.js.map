{"version":3,"sources":["../../../../Documents/GitHub/JJSploit/client/node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.js"],"names":["__webpack_require__","r","__webpack_exports__","d","conf","language","comments","lineComment","brackets","surroundingPairs","open","close","autoClosingPairs","notIn","indentationRules","increaseIndentPattern","decreaseIndentPattern","defaultToken","tokenPostfix","token","declarationKeywords","operatorKeywords","namespaceKeywords","otherKeywords","constants","nameBuiltin","operator","variableName","atomName","specialAtomName","aliasPart","moduleName","sigilSymmetricDelimiter","sigilStartDelimiter","sigilEndDelimiter","decimal","hex","octal","binary","escape","tokenizer","root","include","whitespace","keywordsShorthand","next","doubleQuotedStringKeyword","singleQuotedStringKeyword","numbers","identifiers","cases","unquote","@default","@declarationKeywords","@namespaceKeywords","@otherKeywords","@operatorKeywords","@constants","@nameBuiltin","_.*","strings","doubleQuotedHeredoc","singleQuotedHeredoc","doubleQuotedString","singleQuotedString","atoms","doubleQuotedStringAtom","singleQuotedStringAtom","sigils","sigil","switchTo","sigilStart.interpol.s","sigilContinue.interpol.s","$1==$S5","sigilStart.noInterpol.S","sigilContinue.noInterpol.S","sigilStart.interpol.r","sigilContinue.interpol.r","sigilStart.noInterpol.R","sigilContinue.noInterpol.R","sigilStart.interpol","sigilContinue.interpol","sigilStart.noInterpol","sigilContinue.noInterpol","attributes","doubleQuotedHeredocDocstring","doubleQuotedStringDocstring","symbols","stringContentInterpol","stringContent","stringConstantContentInterpol","stringConstantContent","regexpContentInterpol","regexpContent","sigilContentInterpol","sigilContent","docstringContent","escapeChar","interpolation","interpolationContinue"],"mappings":"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","file":"static/js/23.5c236d5d.chunk.js","sourcesContent":["/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\nexport var conf = {\n  comments: {\n    lineComment: '#'\n  },\n  brackets: [['{', '}'], ['[', ']'], ['(', ')']],\n  surroundingPairs: [{\n    open: '{',\n    close: '}'\n  }, {\n    open: '[',\n    close: ']'\n  }, {\n    open: '(',\n    close: ')'\n  }, {\n    open: \"'\",\n    close: \"'\"\n  }, {\n    open: '\"',\n    close: '\"'\n  }],\n  autoClosingPairs: [{\n    open: \"'\",\n    close: \"'\",\n    notIn: ['string', 'comment']\n  }, {\n    open: '\"',\n    close: '\"',\n    notIn: ['comment']\n  }, {\n    open: '\"\"\"',\n    close: '\"\"\"'\n  }, {\n    open: '`',\n    close: '`',\n    notIn: ['string', 'comment']\n  }, {\n    open: '(',\n    close: ')'\n  }, {\n    open: '{',\n    close: '}'\n  }, {\n    open: '[',\n    close: ']'\n  }, {\n    open: '<<',\n    close: '>>'\n  }],\n  indentationRules: {\n    increaseIndentPattern: /^\\s*(after|else|catch|rescue|fn|[^#]*(do|<\\-|\\->|\\{|\\[|\\=))\\s*$/,\n    decreaseIndentPattern: /^\\s*((\\}|\\])\\s*$|(after|else|catch|rescue|end)\\b)/\n  }\n};\n/**\r\n * A Monarch lexer for the Elixir language.\r\n *\r\n * References:\r\n *\r\n * * Monarch documentation - https://microsoft.github.io/monaco-editor/monarch.html\r\n * * Elixir lexer - https://github.com/elixir-makeup/makeup_elixir/blob/master/lib/makeup/lexers/elixir_lexer.ex\r\n * * TextMate lexer (elixir-tmbundle) - https://github.com/elixir-editors/elixir-tmbundle/blob/master/Syntaxes/Elixir.tmLanguage\r\n * * TextMate lexer (vscode-elixir-ls) - https://github.com/elixir-lsp/vscode-elixir-ls/blob/master/syntaxes/elixir.json\r\n */\n\nexport var language = {\n  defaultToken: 'source',\n  tokenPostfix: '.elixir',\n  brackets: [{\n    open: '[',\n    close: ']',\n    token: 'delimiter.square'\n  }, {\n    open: '(',\n    close: ')',\n    token: 'delimiter.parenthesis'\n  }, {\n    open: '{',\n    close: '}',\n    token: 'delimiter.curly'\n  }, {\n    open: '<<',\n    close: '>>',\n    token: 'delimiter.angle.special'\n  }],\n  // Below are lists/regexps to which we reference later.\n  declarationKeywords: ['def', 'defp', 'defn', 'defnp', 'defguard', 'defguardp', 'defmacro', 'defmacrop', 'defdelegate', 'defcallback', 'defmacrocallback', 'defmodule', 'defprotocol', 'defexception', 'defimpl', 'defstruct'],\n  operatorKeywords: ['and', 'in', 'not', 'or', 'when'],\n  namespaceKeywords: ['alias', 'import', 'require', 'use'],\n  otherKeywords: ['after', 'case', 'catch', 'cond', 'do', 'else', 'end', 'fn', 'for', 'if', 'quote', 'raise', 'receive', 'rescue', 'super', 'throw', 'try', 'unless', 'unquote_splicing', 'unquote', 'with'],\n  constants: ['true', 'false', 'nil'],\n  nameBuiltin: ['__MODULE__', '__DIR__', '__ENV__', '__CALLER__', '__STACKTRACE__'],\n  // Matches any of the operator names:\n  // <<< >>> ||| &&& ^^^ ~~~ === !== ~>> <~> |~> <|> == != <= >= && || \\\\ <> ++ -- |> =~ -> <- ~> <~ :: .. = < > + - * / | . ^ & !\n  operator: /-[->]?|!={0,2}|\\*|\\/|\\\\\\\\|&{1,3}|\\.\\.?|\\^(?:\\^\\^)?|\\+\\+?|<(?:-|<<|=|>|\\|>|~>?)?|=~|={1,3}|>(?:=|>>)?|\\|~>|\\|>|\\|{1,3}|~>>?|~~~|::/,\n  // See https://hexdocs.pm/elixir/syntax-reference.html#variables\n  variableName: /[a-z_][a-zA-Z0-9_]*[?!]?/,\n  // See https://hexdocs.pm/elixir/syntax-reference.html#atoms\n  atomName: /[a-zA-Z_][a-zA-Z0-9_@]*[?!]?|@specialAtomName|@operator/,\n  specialAtomName: /\\.\\.\\.|<<>>|%\\{\\}|%|\\{\\}/,\n  aliasPart: /[A-Z][a-zA-Z0-9_]*/,\n  moduleName: /@aliasPart(?:\\.@aliasPart)*/,\n  // Sigil pairs are: \"\"\" \"\"\", ''' ''', \" \", ' ', / /, | |, < >, { }, [ ], ( )\n  sigilSymmetricDelimiter: /\"\"\"|'''|\"|'|\\/|\\|/,\n  sigilStartDelimiter: /@sigilSymmetricDelimiter|<|\\{|\\[|\\(/,\n  sigilEndDelimiter: /@sigilSymmetricDelimiter|>|\\}|\\]|\\)/,\n  decimal: /\\d(?:_?\\d)*/,\n  hex: /[0-9a-fA-F](_?[0-9a-fA-F])*/,\n  octal: /[0-7](_?[0-7])*/,\n  binary: /[01](_?[01])*/,\n  // See https://hexdocs.pm/elixir/master/String.html#module-escape-characters\n  escape: /\\\\u[0-9a-fA-F]{4}|\\\\x[0-9a-fA-F]{2}|\\\\./,\n  // The keys below correspond to tokenizer states.\n  // We start from the root state and match against its rules\n  // until we explicitly transition into another state.\n  // The `include` simply brings in all operations from the given state\n  // and is useful for improving readability.\n  tokenizer: {\n    root: [{\n      include: '@whitespace'\n    }, {\n      include: '@comments'\n    }, // Keywords start as either an identifier or a string,\n    // but end with a : so it's important to match this first.\n    {\n      include: '@keywordsShorthand'\n    }, {\n      include: '@numbers'\n    }, {\n      include: '@identifiers'\n    }, {\n      include: '@strings'\n    }, {\n      include: '@atoms'\n    }, {\n      include: '@sigils'\n    }, {\n      include: '@attributes'\n    }, {\n      include: '@symbols'\n    }],\n    // Whitespace\n    whitespace: [[/\\s+/, 'white']],\n    // Comments\n    comments: [[/(#)(.*)/, ['comment.punctuation', 'comment']]],\n    // Keyword list shorthand\n    keywordsShorthand: [[/(@atomName)(:)/, ['constant', 'constant.punctuation']], // Use positive look-ahead to ensure the string is followed by :\n    // and should be considered a keyword.\n    [/\"(?=([^\"]|#\\{.*?\\}|\\\\\")*\":)/, {\n      token: 'constant.delimiter',\n      next: '@doubleQuotedStringKeyword'\n    }], [/'(?=([^']|#\\{.*?\\}|\\\\')*':)/, {\n      token: 'constant.delimiter',\n      next: '@singleQuotedStringKeyword'\n    }]],\n    doubleQuotedStringKeyword: [[/\":/, {\n      token: 'constant.delimiter',\n      next: '@pop'\n    }], {\n      include: '@stringConstantContentInterpol'\n    }],\n    singleQuotedStringKeyword: [[/':/, {\n      token: 'constant.delimiter',\n      next: '@pop'\n    }], {\n      include: '@stringConstantContentInterpol'\n    }],\n    // Numbers\n    numbers: [[/0b@binary/, 'number.binary'], [/0o@octal/, 'number.octal'], [/0x@hex/, 'number.hex'], [/@decimal\\.@decimal([eE]-?@decimal)?/, 'number.float'], [/@decimal/, 'number']],\n    // Identifiers\n    identifiers: [// Tokenize identifier name in function-like definitions.\n    // Note: given `def a + b, do: nil`, `a` is not a function name,\n    // so we use negative look-ahead to ensure there's no operator.\n    [/\\b(defp?|defnp?|defmacrop?|defguardp?|defdelegate)(\\s+)(@variableName)(?!\\s+@operator)/, ['keyword.declaration', 'white', {\n      cases: {\n        unquote: 'keyword',\n        '@default': 'function'\n      }\n    }]], // Tokenize function calls\n    [// In-scope call - an identifier followed by ( or .(\n    /(@variableName)(?=\\s*\\.?\\s*\\()/, {\n      cases: {\n        // Tokenize as keyword in cases like `if(..., do: ..., else: ...)`\n        '@declarationKeywords': 'keyword.declaration',\n        '@namespaceKeywords': 'keyword',\n        '@otherKeywords': 'keyword',\n        '@default': 'function.call'\n      }\n    }], [// Referencing function in a module\n    /(@moduleName)(\\s*)(\\.)(\\s*)(@variableName)/, ['type.identifier', 'white', 'operator', 'white', 'function.call']], [// Referencing function in an Erlang module\n    /(:)(@atomName)(\\s*)(\\.)(\\s*)(@variableName)/, ['constant.punctuation', 'constant', 'white', 'operator', 'white', 'function.call']], [// Piping into a function (tokenized separately as it may not have parentheses)\n    /(\\|>)(\\s*)(@variableName)/, ['operator', 'white', {\n      cases: {\n        '@otherKeywords': 'keyword',\n        '@default': 'function.call'\n      }\n    }]], [// Function reference passed to another function\n    /(&)(\\s*)(@variableName)/, ['operator', 'white', 'function.call']], // Language keywords, builtins, constants and variables\n    [/@variableName/, {\n      cases: {\n        '@declarationKeywords': 'keyword.declaration',\n        '@operatorKeywords': 'keyword.operator',\n        '@namespaceKeywords': 'keyword',\n        '@otherKeywords': 'keyword',\n        '@constants': 'constant.language',\n        '@nameBuiltin': 'variable.language',\n        '_.*': 'comment.unused',\n        '@default': 'identifier'\n      }\n    }], // Module names\n    [/@moduleName/, 'type.identifier']],\n    // Strings\n    strings: [[/\"\"\"/, {\n      token: 'string.delimiter',\n      next: '@doubleQuotedHeredoc'\n    }], [/'''/, {\n      token: 'string.delimiter',\n      next: '@singleQuotedHeredoc'\n    }], [/\"/, {\n      token: 'string.delimiter',\n      next: '@doubleQuotedString'\n    }], [/'/, {\n      token: 'string.delimiter',\n      next: '@singleQuotedString'\n    }]],\n    doubleQuotedHeredoc: [[/\"\"\"/, {\n      token: 'string.delimiter',\n      next: '@pop'\n    }], {\n      include: '@stringContentInterpol'\n    }],\n    singleQuotedHeredoc: [[/'''/, {\n      token: 'string.delimiter',\n      next: '@pop'\n    }], {\n      include: '@stringContentInterpol'\n    }],\n    doubleQuotedString: [[/\"/, {\n      token: 'string.delimiter',\n      next: '@pop'\n    }], {\n      include: '@stringContentInterpol'\n    }],\n    singleQuotedString: [[/'/, {\n      token: 'string.delimiter',\n      next: '@pop'\n    }], {\n      include: '@stringContentInterpol'\n    }],\n    // Atoms\n    atoms: [[/(:)(@atomName)/, ['constant.punctuation', 'constant']], [/:\"/, {\n      token: 'constant.delimiter',\n      next: '@doubleQuotedStringAtom'\n    }], [/:'/, {\n      token: 'constant.delimiter',\n      next: '@singleQuotedStringAtom'\n    }]],\n    doubleQuotedStringAtom: [[/\"/, {\n      token: 'constant.delimiter',\n      next: '@pop'\n    }], {\n      include: '@stringConstantContentInterpol'\n    }],\n    singleQuotedStringAtom: [[/'/, {\n      token: 'constant.delimiter',\n      next: '@pop'\n    }], {\n      include: '@stringConstantContentInterpol'\n    }],\n    // Sigils\n    // See https://elixir-lang.org/getting-started/sigils.html\n    // Sigils allow for typing values using their textual representation.\n    // All sigils start with ~ followed by a letter indicating sigil type\n    // and then a delimiter pair enclosing the textual representation.\n    // Optional modifiers are allowed after the closing delimiter.\n    // For instance a regular expressions can be written as:\n    // ~r/foo|bar/ ~r{foo|bar} ~r/foo|bar/g\n    //\n    // In general lowercase sigils allow for interpolation\n    // and escaped characters, whereas uppercase sigils don't\n    //\n    // During tokenization we want to distinguish some\n    // specific sigil types, namely string and regexp,\n    // so that they cen be themed separately.\n    //\n    // To reasonably handle all those combinations we leverage\n    // dot-separated states, so if we transition to @sigilStart.interpol.s.{.}\n    // then \"sigilStart.interpol.s\" state will match and also all\n    // the individual dot-separated parameters can be accessed.\n    sigils: [[/~[a-z]@sigilStartDelimiter/, {\n      token: '@rematch',\n      next: '@sigil.interpol'\n    }], [/~[A-Z]@sigilStartDelimiter/, {\n      token: '@rematch',\n      next: '@sigil.noInterpol'\n    }]],\n    sigil: [[/~([a-zA-Z])\\{/, {\n      token: '@rematch',\n      switchTo: '@sigilStart.$S2.$1.{.}'\n    }], [/~([a-zA-Z])\\[/, {\n      token: '@rematch',\n      switchTo: '@sigilStart.$S2.$1.[.]'\n    }], [/~([a-zA-Z])\\(/, {\n      token: '@rematch',\n      switchTo: '@sigilStart.$S2.$1.(.)'\n    }], [/~([a-zA-Z])\\</, {\n      token: '@rematch',\n      switchTo: '@sigilStart.$S2.$1.<.>'\n    }], [/~([a-zA-Z])(@sigilSymmetricDelimiter)/, {\n      token: '@rematch',\n      switchTo: '@sigilStart.$S2.$1.$2.$2'\n    }]],\n    // The definitions below expect states to be of the form:\n    //\n    // sigilStart.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>\n    // sigilContinue.<interpol-or-noInterpol>.<sigil-letter>.<start-delimiter>.<end-delimiter>\n    //\n    // The sigilStart state is used only to properly classify the token (as string/regex/sigil)\n    // and immediately switches to the sigilContinue sate, which handles the actual content\n    // and waits for the corresponding end delimiter.\n    'sigilStart.interpol.s': [[/~s@sigilStartDelimiter/, {\n      token: 'string.delimiter',\n      switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n    }]],\n    'sigilContinue.interpol.s': [[/(@sigilEndDelimiter)[a-zA-Z]*/, {\n      cases: {\n        '$1==$S5': {\n          token: 'string.delimiter',\n          next: '@pop'\n        },\n        '@default': 'string'\n      }\n    }], {\n      include: '@stringContentInterpol'\n    }],\n    'sigilStart.noInterpol.S': [[/~S@sigilStartDelimiter/, {\n      token: 'string.delimiter',\n      switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n    }]],\n    'sigilContinue.noInterpol.S': [// Ignore escaped sigil end\n    [/(^|[^\\\\])\\\\@sigilEndDelimiter/, 'string'], [/(@sigilEndDelimiter)[a-zA-Z]*/, {\n      cases: {\n        '$1==$S5': {\n          token: 'string.delimiter',\n          next: '@pop'\n        },\n        '@default': 'string'\n      }\n    }], {\n      include: '@stringContent'\n    }],\n    'sigilStart.interpol.r': [[/~r@sigilStartDelimiter/, {\n      token: 'regexp.delimiter',\n      switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n    }]],\n    'sigilContinue.interpol.r': [[/(@sigilEndDelimiter)[a-zA-Z]*/, {\n      cases: {\n        '$1==$S5': {\n          token: 'regexp.delimiter',\n          next: '@pop'\n        },\n        '@default': 'regexp'\n      }\n    }], {\n      include: '@regexpContentInterpol'\n    }],\n    'sigilStart.noInterpol.R': [[/~R@sigilStartDelimiter/, {\n      token: 'regexp.delimiter',\n      switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n    }]],\n    'sigilContinue.noInterpol.R': [// Ignore escaped sigil end\n    [/(^|[^\\\\])\\\\@sigilEndDelimiter/, 'regexp'], [/(@sigilEndDelimiter)[a-zA-Z]*/, {\n      cases: {\n        '$1==$S5': {\n          token: 'regexp.delimiter',\n          next: '@pop'\n        },\n        '@default': 'regexp'\n      }\n    }], {\n      include: '@regexpContent'\n    }],\n    // Fallback to the generic sigil by default\n    'sigilStart.interpol': [[/~([a-zA-Z])@sigilStartDelimiter/, {\n      token: 'sigil.delimiter',\n      switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n    }]],\n    'sigilContinue.interpol': [[/(@sigilEndDelimiter)[a-zA-Z]*/, {\n      cases: {\n        '$1==$S5': {\n          token: 'sigil.delimiter',\n          next: '@pop'\n        },\n        '@default': 'sigil'\n      }\n    }], {\n      include: '@sigilContentInterpol'\n    }],\n    'sigilStart.noInterpol': [[/~([a-zA-Z])@sigilStartDelimiter/, {\n      token: 'sigil.delimiter',\n      switchTo: '@sigilContinue.$S2.$S3.$S4.$S5'\n    }]],\n    'sigilContinue.noInterpol': [// Ignore escaped sigil end\n    [/(^|[^\\\\])\\\\@sigilEndDelimiter/, 'sigil'], [/(@sigilEndDelimiter)[a-zA-Z]*/, {\n      cases: {\n        '$1==$S5': {\n          token: 'sigil.delimiter',\n          next: '@pop'\n        },\n        '@default': 'sigil'\n      }\n    }], {\n      include: '@sigilContent'\n    }],\n    // Attributes\n    attributes: [// Module @doc* attributes - tokenized as comments\n    [/\\@(module|type)?doc (~[sS])?\"\"\"/, {\n      token: 'comment.block.documentation',\n      next: '@doubleQuotedHeredocDocstring'\n    }], [/\\@(module|type)?doc (~[sS])?\"/, {\n      token: 'comment.block.documentation',\n      next: '@doubleQuotedStringDocstring'\n    }], [/\\@(module|type)?doc false/, 'comment.block.documentation'], // Module attributes\n    [/\\@(@variableName)/, 'variable']],\n    doubleQuotedHeredocDocstring: [[/\"\"\"/, {\n      token: 'comment.block.documentation',\n      next: '@pop'\n    }], {\n      include: '@docstringContent'\n    }],\n    doubleQuotedStringDocstring: [[/\"/, {\n      token: 'comment.block.documentation',\n      next: '@pop'\n    }], {\n      include: '@docstringContent'\n    }],\n    // Operators, punctuation, brackets\n    symbols: [// Code point operator (either with regular character ?a or an escaped one ?\\n)\n    [/\\?(\\\\.|[^\\\\\\s])/, 'number.constant'], // Anonymous function arguments\n    [/&\\d+/, 'operator'], // Bitshift operators (must go before delimiters, so that << >> don't match first)\n    [/<<<|>>>/, 'operator'], // Delimiter pairs\n    [/[()\\[\\]\\{\\}]|<<|>>/, '@brackets'], // Triple dot is a valid name (must go before operators, so that .. doesn't match instead)\n    [/\\.\\.\\./, 'identifier'], // Punctuation => (must go before operators, so it's not tokenized as = then >)\n    [/=>/, 'punctuation'], // Operators\n    [/@operator/, 'operator'], // Punctuation\n    [/[:;,.%]/, 'punctuation']],\n    // Generic helpers\n    stringContentInterpol: [{\n      include: '@interpolation'\n    }, {\n      include: '@escapeChar'\n    }, {\n      include: '@stringContent'\n    }],\n    stringContent: [[/./, 'string']],\n    stringConstantContentInterpol: [{\n      include: '@interpolation'\n    }, {\n      include: '@escapeChar'\n    }, {\n      include: '@stringConstantContent'\n    }],\n    stringConstantContent: [[/./, 'constant']],\n    regexpContentInterpol: [{\n      include: '@interpolation'\n    }, {\n      include: '@escapeChar'\n    }, {\n      include: '@regexpContent'\n    }],\n    regexpContent: [// # may be a regular regexp char, so we use a heuristic\n    // assuming a # surrounded by whitespace is actually a comment.\n    [/(\\s)(#)(\\s.*)$/, ['white', 'comment.punctuation', 'comment']], [/./, 'regexp']],\n    sigilContentInterpol: [{\n      include: '@interpolation'\n    }, {\n      include: '@escapeChar'\n    }, {\n      include: '@sigilContent'\n    }],\n    sigilContent: [[/./, 'sigil']],\n    docstringContent: [[/./, 'comment.block.documentation']],\n    escapeChar: [[/@escape/, 'constant.character.escape']],\n    interpolation: [[/#{/, {\n      token: 'delimiter.bracket.embed',\n      next: '@interpolationContinue'\n    }]],\n    interpolationContinue: [[/}/, {\n      token: 'delimiter.bracket.embed',\n      next: '@pop'\n    }], // Interpolation brackets may contain arbitrary code,\n    // so we simply match against all the root rules,\n    // until we reach interpolation end (the above matches).\n    {\n      include: '@root'\n    }]\n  }\n};"],"sourceRoot":""}